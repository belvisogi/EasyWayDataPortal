<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>DB Diagram Viewer - Prototype</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; font-family: Arial, sans-serif; color:#222; }
    header { padding:14px 16px; border-bottom:1px solid #e6e6e6; background:#fff; }
    .muted { color:#666; font-size:13px; }
    .wrap { display:flex; height: calc(100vh - 58px); }
    .sidebar { width: 360px; border-right:1px solid #e6e6e6; padding:12px 12px; overflow:auto; background:#fafafa; }
    .main { flex:1; position:relative; }
    canvas { width:100%; height:100%; display:block; background:#fff; }
    .panel { margin-bottom:14px; padding:10px; background:#fff; border:1px solid #e6e6e6; border-radius:6px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:6px 10px; border:1px solid #ccc; border-radius:6px; background:#fff; cursor:pointer; }
    button:hover { background:#f2f2f2; }
    label { font-size:13px; }
    input[type="checkbox"] { transform: translateY(1px); }
    .list { margin:6px 0 0 0; padding-left:18px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:12px; font-size:12px; border:1px solid #ddd; background:#f7f7f7; margin-left:6px; }
    .k-explicit { border-color:#2b2; color:#173; background:#eef9ee; }
    .k-inferred { border-color:#99a; color:#334; background:#f1f2ff; }
    .table-name { font-weight:600; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <div class="row" style="justify-content:space-between;">
      <div>
        <div style="font-size:18px; font-weight:700;">DB Diagram Viewer - Prototype</div>
        <div class="muted">Viewer interno senza dipendenze esterne: carica un JSON generato da <span class="code">scripts/db-export-portal-diagram.ps1</span>.</div>
      </div>
      <div class="muted"><span id="schemaBadge"></span></div>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <div class="panel">
        <div class="row">
          <label for="fileInput">Carica diagram JSON:</label>
          <input id="fileInput" type="file" accept=".json" />
        </div>
        <div class="row" style="margin-top:8px;">
          <button id="loadMock">Carica mock</button>
          <button id="relayout">Re-layout</button>
          <button id="reset">Reset view</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <label><input id="toggleInferred" type="checkbox" checked /> mostra relazioni inferite</label>
        </div>
      </div>

      <div class="panel">
        <div><strong>Selezione</strong></div>
        <div id="selection" class="muted" style="margin-top:6px;">Nessuna tabella selezionata.</div>
        <div id="selectionCols" class="muted" style="margin-top:8px;"></div>
      </div>

      <div class="panel">
        <div class="row" style="justify-content:space-between;">
          <strong>Tabelle</strong>
          <span class="muted"><span id="tableCount">0</span></span>
        </div>
        <ul id="tableList" class="list"></ul>
      </div>

      <div class="panel">
        <div><strong>Legenda</strong></div>
        <div class="muted" style="margin-top:6px;">
          <div><span class="pill k-explicit">explicit</span> vincolo FK nel DDL</div>
          <div style="margin-top:4px;"><span class="pill k-inferred">inferred</span> relazione da convenzione (es. tenant_id)</div>
        </div>
      </div>
    </aside>

    <main class="main">
      <canvas id="c"></canvas>
    </main>
  </div>

  <script>
    const mockUrl = './mock/portal-diagram-sample.json';
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let model = null;
    let nodes = [];
    let edges = [];
    let showInferred = true;
    let selectedNodeId = null;
    let panX = 0, panY = 0, zoom = 1;
    let isPanning = false;
    let panStart = null;

    function resizeCanvas() {
      const r = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    function setSchemaBadge(s) {
      document.getElementById('schemaBadge').textContent = s ? ('schema: ' + s) : '';
    }

    function loadModel(m) {
      model = m;
      setSchemaBadge(m?.schema || '');

      const colMap = new Map();
      (m.columns || []).forEach(t => colMap.set(t.table, t.columns || []));

      nodes = (m.nodes || []).map((n, i) => {
        const id = n.id || (n.schema + '.' + n.table);
        const label = id;
        return {
          id,
          label,
          cols: colMap.get(id) || [],
          x: 80 + (i % 4) * 220 + Math.random() * 30,
          y: 80 + Math.floor(i / 4) * 160 + Math.random() * 30,
          vx: 0,
          vy: 0
        };
      });
      const nodeIds = new Set(nodes.map(n => n.id));

      edges = (m.edges || [])
        .filter(e => nodeIds.has(e.from) && nodeIds.has(e.to))
        .map(e => ({
          from: e.from,
          to: e.to,
          fromColumn: e.fromColumn || '',
          toColumn: e.toColumn || '',
          kind: e.kind || 'inferred',
          reason: e.reason || '',
          confidence: e.confidence || ''
        }));

      selectedNodeId = null;
      panX = 0; panY = 0; zoom = 1;
      updateSidebar();
      relayout();
    }

    function updateSidebar() {
      document.getElementById('tableCount').textContent = String(nodes.length);
      const list = document.getElementById('tableList');
      list.innerHTML = '';
      nodes
        .slice()
        .sort((a,b) => a.label.localeCompare(b.label))
        .forEach(n => {
          const li = document.createElement('li');
          li.style.cursor = 'pointer';
          li.innerHTML = '<span class="table-name">' + escapeHtml(n.label) + '</span>';
          li.onclick = () => { selectedNodeId = n.id; centerOn(n); updateSelection(); draw(); };
          list.appendChild(li);
        });

      updateSelection();
    }

    function updateSelection() {
      const sel = nodes.find(n => n.id === selectedNodeId);
      const el = document.getElementById('selection');
      const colsEl = document.getElementById('selectionCols');
      if (!sel) {
        el.textContent = 'Nessuna tabella selezionata.';
        colsEl.textContent = '';
        return;
      }
      el.innerHTML = '<div class="table-name">' + escapeHtml(sel.label) + '</div>';

      const cols = (sel.cols || []).map(c => {
        const nn = c.name || '';
        const tt = c.sql_type || '';
        return '- ' + nn + (tt ? (' (' + tt + ')') : '');
      });
      colsEl.innerHTML = '<div class="muted" style="margin-top:6px;"><strong>Colonne</strong></div>' +
        '<pre class="code" style="white-space:pre-wrap; background:#f7f7f7; padding:8px; border-radius:6px; border:1px solid #e6e6e6; overflow:auto;">' +
        escapeHtml(cols.join('\n')) +
        '</pre>';
    }

    function relayout() {
      // Simple force-directed layout (small graphs): repulsion + spring edges.
      const byId = new Map(nodes.map(n => [n.id, n]));
      const visibleEdges = edges.filter(e => showInferred || e.kind !== 'inferred');

      const iterations = 450;
      const repulsion = 22000;
      const spring = 0.010;
      const springLen = 180;
      const damping = 0.82;

      for (let it = 0; it < iterations; it++) {
        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i], b = nodes[j];
            let dx = a.x - b.x, dy = a.y - b.y;
            let dist2 = dx*dx + dy*dy + 0.01;
            const f = repulsion / dist2;
            const dist = Math.sqrt(dist2);
            const fx = (dx / dist) * f;
            const fy = (dy / dist) * f;
            a.vx += fx; a.vy += fy;
            b.vx -= fx; b.vy -= fy;
          }
        }
        // Springs
        for (const e of visibleEdges) {
          const a = byId.get(e.from), b = byId.get(e.to);
          if (!a || !b) continue;
          let dx = b.x - a.x, dy = b.y - a.y;
          let dist = Math.sqrt(dx*dx + dy*dy) + 0.001;
          const force = spring * (dist - springLen);
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          a.vx += fx; a.vy += fy;
          b.vx -= fx; b.vy -= fy;
        }
        // Integrate
        for (const n of nodes) {
          n.vx *= damping;
          n.vy *= damping;
          n.x += n.vx * 0.03;
          n.y += n.vy * 0.03;
        }
      }
      draw();
    }

    function worldToScreen(x, y) {
      return { x: (x + panX) * zoom, y: (y + panY) * zoom };
    }
    function screenToWorld(x, y) {
      return { x: x / zoom - panX, y: y / zoom - panY };
    }

    function nodeBox(n) {
      const txt = n.label;
      const w = Math.max(140, 10 + txt.length * 7);
      const h = 44;
      return { x: n.x - w/2, y: n.y - h/2, w, h };
    }

    function draw() {
      if (!ctx) return;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      ctx.clearRect(0, 0, w, h);

      if (!model) {
        ctx.fillStyle = '#666';
        ctx.font = '14px Arial';
        ctx.fillText('Carica un file JSON per visualizzare il diagramma.', 16, 24);
        return;
      }

      const byId = new Map(nodes.map(n => [n.id, n]));
      const visibleEdges = edges.filter(e => showInferred || e.kind !== 'inferred');

      // Edges
      for (const e of visibleEdges) {
        const a = byId.get(e.from), b = byId.get(e.to);
        if (!a || !b) continue;
        const A = worldToScreen(a.x, a.y);
        const B = worldToScreen(b.x, b.y);

        ctx.beginPath();
        ctx.lineWidth = (e.kind === 'explicit') ? 1.6 : 1.0;
        ctx.strokeStyle = (e.kind === 'explicit') ? '#2b7' : '#778';
        ctx.setLineDash((e.kind === 'explicit') ? [] : [6, 4]);
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Nodes
      for (const n of nodes) {
        const box = nodeBox(n);
        const tl = worldToScreen(box.x, box.y);
        const ww = box.w * zoom;
        const hh = box.h * zoom;

        const isSel = (n.id === selectedNodeId);
        ctx.fillStyle = isSel ? '#e8f4ff' : '#fff';
        ctx.strokeStyle = isSel ? '#2680d9' : '#cfcfcf';
        ctx.lineWidth = isSel ? 2 : 1;
        roundRect(ctx, tl.x, tl.y, ww, hh, 8);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#222';
        ctx.font = `${Math.max(11, 12 * zoom)}px Arial`;
        ctx.textBaseline = 'middle';
        ctx.fillText(n.label, tl.x + 10, tl.y + hh/2);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function centerOn(n) {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      panX = (w / (2 * zoom)) - n.x;
      panY = (h / (2 * zoom)) - n.y;
    }

    function resetView() {
      panX = 0; panY = 0; zoom = 1;
      draw();
    }

    function escapeHtml(s) {
      if (!s && s !== '') return '';
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    // Events: click to select, wheel to zoom, drag to pan
    canvas.addEventListener('mousedown', (ev) => {
      isPanning = true;
      panStart = { x: ev.clientX, y: ev.clientY, panX, panY };
    });
    window.addEventListener('mouseup', () => { isPanning = false; panStart = null; });
    window.addEventListener('mousemove', (ev) => {
      if (!isPanning || !panStart) return;
      const dx = (ev.clientX - panStart.x) / zoom;
      const dy = (ev.clientY - panStart.y) / zoom;
      panX = panStart.panX + dx;
      panY = panStart.panY + dy;
      draw();
    });

    canvas.addEventListener('click', (ev) => {
      if (!model) return;
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const p = screenToWorld(x, y);

      // Hit test
      for (const n of nodes) {
        const b = nodeBox(n);
        if (p.x >= b.x && p.x <= (b.x + b.w) && p.y >= b.y && p.y <= (b.y + b.h)) {
          selectedNodeId = n.id;
          updateSelection();
          draw();
          return;
        }
      }
      selectedNodeId = null;
      updateSelection();
      draw();
    });

    canvas.addEventListener('wheel', (ev) => {
      ev.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const before = screenToWorld(mx, my);

      const delta = ev.deltaY;
      const factor = delta > 0 ? 0.92 : 1.08;
      zoom = Math.max(0.45, Math.min(2.8, zoom * factor));

      const after = screenToWorld(mx, my);
      panX += (after.x - before.x);
      panY += (after.y - before.y);
      draw();
    }, { passive: false });

    async function loadMock() {
      const r = await fetch(mockUrl);
      const j = await r.json();
      loadModel(j);
    }

    document.getElementById('loadMock').addEventListener('click', () => {
      loadMock().catch(e => alert('Impossibile caricare mock: ' + e.message));
    });
    document.getElementById('relayout').addEventListener('click', () => relayout());
    document.getElementById('reset').addEventListener('click', () => resetView());
    document.getElementById('toggleInferred').addEventListener('change', (ev) => {
      showInferred = !!ev.target.checked;
      draw();
    });

    document.getElementById('fileInput').addEventListener('change', (ev) => {
      const f = ev.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const j = JSON.parse(e.target.result);
          loadModel(j);
        } catch (err) {
          alert('JSON non valido: ' + err.message);
        }
      };
      reader.readAsText(f);
    });

    // boot
    resizeCanvas();
    loadMock().catch(() => draw());
  </script>
</body>
</html>

