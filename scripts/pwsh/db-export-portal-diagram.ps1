<#
Esporta un "diagram model" (JSON) per visualizzare lo schema PORTAL in modo interno (viewer statico),
derivando tabelle/colonne dai file Flyway in `db/flyway/sql/`.

Contesto
- Source-of-truth DB: `db/flyway/sql/`
- Output runtime: `out/` (ignorata da git salvo README)

Output (default):
  - out/db/portal-diagram.json

Note
- Le FK "esplicite" vengono rilevate da vincoli FOREIGN KEY presenti nei DDL.
- Dove mancano FK fisiche (scelta attuale del progetto), il diagramma aggiunge anche "relazioni inferite"
  (es. tenant_id -> PORTAL.TENANT.tenant_id), marcate come `kind=inferred`.
#>

[CmdletBinding()]
param(
  [string]$FlywaySqlDir = "db/flyway/sql",
  [string]$Schema = "PORTAL",
  [string]$OutJson = "out/db/portal-diagram.json"
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

function Ensure-Dir([string]$p) {
  if (-not $p) { return }
  if (-not (Test-Path -LiteralPath $p)) { New-Item -ItemType Directory -Force -Path $p | Out-Null }
}

function Normalize-Ident([string]$s) {
  if ([string]::IsNullOrWhiteSpace($s)) { return '' }
  return ($s.Trim() -replace '\s+','_')
}

function Extract-CreateTableBlocks {
  param([string]$Text, [string]$SchemaName)

  $schemaU = $SchemaName.Trim().ToUpperInvariant()
  $rx = [regex]::new("(?im)\bCREATE\s+TABLE\s+${schemaU}\.(?<table>[A-Za-z0-9_]+)\b", [System.Text.RegularExpressions.RegexOptions]::None)
  $blocks = [System.Collections.Generic.List[object]]::new()

  foreach ($m in $rx.Matches($Text)) {
    $tableName = $m.Groups['table'].Value
    $start = $m.Index + $m.Length
    $open = $Text.IndexOf([char]'(', $start)
    if ($open -lt 0) { continue }

    $depth = 0
    $i = $open
    $end = -1
    while ($i -lt $Text.Length) {
      $ch = [char]$Text[$i]
      if ($ch -eq [char]'(') { $depth++ }
      elseif ($ch -eq [char]')') {
        $depth--
        if ($depth -eq 0) { $end = $i; break }
      }
      $i++
    }
    if ($end -lt 0) { continue }

    $body = $Text.Substring($open + 1, ($end - $open - 1))
    $blocks.Add([ordered]@{ table = $tableName; body = $body }) | Out-Null
  }

  return $blocks.ToArray()
}

if (-not (Test-Path -LiteralPath $FlywaySqlDir)) { throw "Flyway sql dir not found: $FlywaySqlDir" }

$sql = ''
Get-ChildItem -LiteralPath $FlywaySqlDir -File -Filter *.sql |
  Sort-Object -Property Name |
  ForEach-Object { $sql += (Get-Content -LiteralPath $_.FullName -Raw) + "`n" }

$schemaNorm = $Schema.Trim().ToUpperInvariant()
$tableBlocks = @(Extract-CreateTableBlocks -Text $sql -SchemaName $schemaNorm)

# Model
$tables = [System.Collections.Generic.Dictionary[string, object]]::new([System.StringComparer]::OrdinalIgnoreCase)
$columnsByTable = [System.Collections.Generic.Dictionary[string, object]]::new([System.StringComparer]::OrdinalIgnoreCase)
$edges = [System.Collections.Generic.List[object]]::new()

foreach ($b in $tableBlocks) {
  $t = Normalize-Ident ([string]$b.table)
  if (-not $t) { continue }
  $full = "${schemaNorm}.${t}"
  if (-not $tables.ContainsKey($full)) {
    $tables[$full] = [ordered]@{
      id = $full
      schema = $schemaNorm
      table = $t
    }
    $columnsByTable[$full] = New-Object System.Collections.Generic.List[object]
  }

  $lines = @(([string]$b.body) -split "`n" | ForEach-Object { $_.Trim().TrimEnd("`r") } | Where-Object { $_ })
  foreach ($line0 in $lines) {
    $line = $line0.Trim().TrimEnd(',')
    if (-not $line) { continue }
    if ($line -match '^(?i)\s*CONSTRAINT\b') { continue }

    $cm = [regex]::Match($line, '^\s*(?:\[(?<col>[A-Za-z0-9_]+)\]|(?<col>[A-Za-z0-9_]+))\s+(?<rest>.+)$')
    if (-not $cm.Success) { continue }
    $col = $cm.Groups['col'].Value
    $rest = $cm.Groups['rest'].Value.Trim()

    $tm = [regex]::Match($rest, '^(?<type>[A-Za-z0-9_]+(?:\s*\([^)]+\))?)\s*(?<after>.*)$')
    if (-not $tm.Success) { continue }
    $sqlType = ($tm.Groups['type'].Value -replace '\s+','').ToLowerInvariant()
    $after = $tm.Groups['after'].Value
    $nullable = $true
    if ($after -match '(?i)\bNOT\s+NULL\b') { $nullable = $false }

    $columnsByTable[$full].Add([ordered]@{
      name = $col
      sql_type = $sqlType
      nullable = $nullable
    }) | Out-Null
  }

  # Explicit FK constraints inside CREATE TABLE (generated by agent)
  $fkInTableRx = [regex]::new("(?im)\bCONSTRAINT\s+\[(?<fk>[^\]]+)\]\s+FOREIGN\s+KEY\s+\(\s*\[(?<col>[A-Za-z0-9_]+)\]\s*\)\s+REFERENCES\s+\[(?<refSchema>[A-Za-z0-9_]+)\]\.\[(?<refTable>[A-Za-z0-9_]+)\]\(\[(?<refCol>[A-Za-z0-9_]+)\]\)", [System.Text.RegularExpressions.RegexOptions]::None)
  foreach ($m in $fkInTableRx.Matches([string]$b.body)) {
    $refSchema = Normalize-Ident $m.Groups['refSchema'].Value
    $refTable = Normalize-Ident $m.Groups['refTable'].Value
    $refCol = Normalize-Ident $m.Groups['refCol'].Value
    $colName = Normalize-Ident $m.Groups['col'].Value
    if (-not $refSchema -or -not $refTable -or -not $refCol -or -not $colName) { continue }
    $toId = ("{0}.{1}" -f $refSchema.ToUpperInvariant(), $refTable.ToUpperInvariant())
    $edges.Add([ordered]@{
      from = $full
      fromColumn = $colName
      to = $toId
      toColumn = $refCol
      kind = 'explicit'
      confidence = 'high'
      reason = 'DDL constraint FOREIGN KEY'
    }) | Out-Null
  }
}

# Edges (explicit + inferred)

# Inferred relationships (project conventions)
function Has-Col([string]$tableId, [string]$colName) {
  if (-not $columnsByTable.ContainsKey($tableId)) { return $false }
  foreach ($c in $columnsByTable[$tableId]) {
    if ((([string]$c.name).ToLowerInvariant()) -eq $colName.ToLowerInvariant()) { return $true }
  }
  return $false
}

function Add-InferredEdge([string]$fromTableId, [string]$fromCol, [string]$toTableId, [string]$toCol, [string]$reason) {
  $edges.Add([ordered]@{
    from = $fromTableId
    fromColumn = $fromCol
    to = $toTableId
    toColumn = $toCol
    kind = 'inferred'
    confidence = 'high'
    reason = $reason
  }) | Out-Null
}

$tenantTable = "${schemaNorm}.TENANT"
$usersTable = "${schemaNorm}.USERS"
$profileDomains = "${schemaNorm}.PROFILE_DOMAINS"

foreach ($t in $tables.Keys) {
  if ($t -eq $tenantTable) { continue }
  if (Has-Col $t 'tenant_id' -and Has-Col $tenantTable 'tenant_id') {
    Add-InferredEdge -fromTableId $t -fromCol 'tenant_id' -toTableId $tenantTable -toCol 'tenant_id' -reason 'Convention: tenant_id references PORTAL.TENANT.tenant_id'
  }
  if ($t -ne $usersTable -and (Has-Col $t 'user_id') -and (Has-Col $usersTable 'user_id')) {
    Add-InferredEdge -fromTableId $t -fromCol 'user_id' -toTableId $usersTable -toCol 'user_id' -reason 'Convention: user_id references PORTAL.USERS.user_id (note: logical composite key may include tenant_id).'
  }
  if ($t -ne $profileDomains -and (Has-Col $t 'profile_code') -and (Has-Col $profileDomains 'profile_code')) {
    Add-InferredEdge -fromTableId $t -fromCol 'profile_code' -toTableId $profileDomains -toCol 'profile_code' -reason 'Convention: profile_code references PORTAL.PROFILE_DOMAINS.profile_code'
  }
}

# Output
$nodes = @($tables.Values) | Sort-Object { $_.id }
$edgesOut = @($edges)
$colsOut = @(
  foreach ($entry in $columnsByTable.GetEnumerator()) {
    $v = $entry.Value
    $arr = if ($v -is [System.Collections.Generic.List[object]]) { $v.ToArray() } else { @($v) }
    [pscustomobject]@{ table = [string]$entry.Key; columns = $arr }
  }
) | Sort-Object -Property table

$model = [ordered]@{
  ok = $true
  schema = $schemaNorm
  sourceOfTruth = [ordered]@{
    flywaySqlDir = $FlywaySqlDir.Replace([char]92,[char]47)
  }
  generatedAtUtc = (Get-Date).ToUniversalTime().ToString('o')
  nodes = $nodes
  columns = $colsOut
  edges = $edgesOut
}

$outDir = Split-Path -Parent $OutJson
if ($outDir) { Ensure-Dir $outDir }
($model | ConvertTo-Json -Depth 8) | Set-Content -LiteralPath $OutJson -Encoding UTF8
($model | ConvertTo-Json -Depth 8)
