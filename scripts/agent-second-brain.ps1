<#
.SYNOPSIS
    Agent Second Brain: Breadcrumbs Generator
    Injects Obsidian-style breadcrumbs based on Knowledge Graph hierarchy.

.DESCRIPTION
    Reads 'agents/memory/knowledge-graph.json' (generated by agent-docs-scanner.ps1)
    and injects a navigation breadcrumb string into every Markdown file.
    
    Breadcrumb Format: [[Home]] > [[Domain]] > [[Page]]
    Injection Point: Immediately after YAML frontmatter.

.PARAMETER Action
    Generate: Injects breadcrumbs into files.
    Clean: Removes breadcrumbs from files.

.PARAMETER DryRun
    If set, only previews changes without modifying files.
#>
param(
    [string]$GraphPath = "agents/memory/knowledge-graph.json",
    [string]$WikiRoot = "Wiki/EasyWayData.wiki",
    [string]$Action = "Generate", # Generate, Clean
    [switch]$DryRun
)

$ErrorActionPreference = "Stop"

function Resolve-TagToPage {
    param($TagKey)
    
    # Heuristic 1: Domain -> domains/X.md
    if ($TagKey -match "^domain/(.+)") {
        $name = $matches[1]
        $candidate = "domains/$name.md"
        if (Test-Path (Join-Path $WikiRoot $candidate)) { return "[[domains/$name|$name]]" }
        
        # Fallback: domains/docs-governance.md for 'docs'
        if ($name -eq "docs" -and (Test-Path (Join-Path $WikiRoot "domains/docs-governance.md"))) {
            return "[[domains/docs-governance|Docs]]"
        }
    }
    
    return $null
}

function Get-Breadcrumb {
    param($PageNode, $RelativePath)
    
    # 1. Start with Home
    $crumbs = @("[[start-here|Home]]") # Better than EasyWayDataPortal
    
    # 2. Add Domain/Layer based on Tags (Hierarchy Game Level 2)
    # Priority: Domain -> Layer
    $tags = $PageNode.tags
    
    $domain = $null
    $layer = $null
    
    foreach ($t in $tags) {
        if ($t -match "^domain/(.+)") { $domain = $matches[1]; $domainKey = $t }
        if ($t -match "^layer/(.+)") { $layer = $matches[1]; $layerKey = $t }
    }
    
    # Domain Link
    if ($domain) { 
        $dLabel = (Get-Culture).TextInfo.ToTitleCase($domain)
        $resolved = Resolve-TagToPage -TagKey $domainKey
        if ($resolved) {
            $crumbs += $resolved
        } else {
            $crumbs += "[[Domain - $dLabel|$dLabel]]" 
        }
    }
    
    # Layer Link (Usually just a virtual Label unless we have indices)
    if ($layer) {
        $lLabel = (Get-Culture).TextInfo.ToTitleCase($layer)
        # Check for Index
        if (Test-Path (Join-Path $WikiRoot "indices/layer/$layer.md")) {
             $crumbs += "[[indices/layer/$layer|$lLabel]]"
        } else {
             $crumbs += "[[Layer - $lLabel|$lLabel]]"
        }
    }
    
    return ($crumbs -join " > ")
}

if (-not (Test-Path $GraphPath)) {
    Write-Error "Knowledge Graph not found at $GraphPath. Run 'agent-docs-scanner.ps1 -Action BuildGraph' first."
    exit 1
}

Write-Host "üß† Agent Second Brain: Loading Knowledge Graph..." -ForegroundColor Cyan
$Graph = Get-Content $GraphPath | ConvertFrom-Json
$FilesProcessed = 0
$FilesUpdated = 0

foreach ($pageName in $Graph.pages.PSObject.Properties.Name) {
    $pageNode = $Graph.pages.$pageName
    $fullPath = Join-Path $PWD $pageName
    
    if (-not (Test-Path $fullPath)) { continue }
    
    $content = Get-Content $fullPath -Raw
    $FilesProcessed++
    
    # Calculate Breadcrumb
    $breadcrumb = Get-Breadcrumb -PageNode $pageNode -RelativePath $pageName
    $crumbString = "$breadcrumb"
    
    # Check if exists
    $hasCrumb = $content -match "(?m)^\[\[.+\]\] > \[\[.+\]\]"
    
    if ($Action -eq "Clean") {
        if ($hasCrumb) {
            Write-Host "   üßπ Cleaning $pageName" -ForegroundColor Yellow
            if (-not $DryRun) {
                $newContent = $content -replace "(?m)^\[\[.+\]\] > \[\[.+\]\].*(\r?\n)?", ""
                Set-Content -Path $fullPath -Value $newContent -Encoding utf8
                $FilesUpdated++
            }
        }
    }
    elseif ($Action -eq "Generate") {
        # Construct the line to inject
        $injectLine = "$crumbString"
        
        if ($hasCrumb) {
            # Update existing
            $currentCrumbLine = [regex]::Match($content, "(?m)^\[\[.+\]\] > \[\[.+\]\].*").Value
            if ($currentCrumbLine.Trim() -ne $injectLine) {
                Write-Host "   üìù Updating $pageName" -ForegroundColor Cyan
                if ($DryRun) { Write-Host "      -> $injectLine" -ForegroundColor DarkGray }
                if (-not $DryRun) {
                    $newContent = $content -replace "(?m)^\[\[.+\]\] > \[\[.+\]\].*", $injectLine
                    Set-Content -Path $fullPath -Value $newContent -Encoding utf8
                    $FilesUpdated++
                }
            }
        }
        else {
            # Insert new (After YAML)
            Write-Host "   ‚ûï Injecting $pageName" -ForegroundColor Green
            if ($DryRun) { Write-Host "      -> $injectLine" -ForegroundColor DarkGray }
            if (-not $DryRun) {
                if ($content -match "(?s)^---\s*\n.+?\n---\s*\n") {
                    $newContent = $content -replace "(?s)^(---\s*\n.+?\n---\s*\n)", "`$1$injectLine`r`n`r`n"
                }
                else {
                    # No frontmatter? Prepend
                    $newContent = "$injectLine`r`n`r`n$content"
                }
                Set-Content -Path $fullPath -Value $newContent -Encoding utf8
                $FilesUpdated++
            }
        }
    }
}

Write-Host "üèÅ Done. Processed: $FilesProcessed. Updated: $FilesUpdated." -ForegroundColor Green
if ($DryRun) { Write-Host " (DryRun Mode - No changes saved)" -ForegroundColor Yellow }
